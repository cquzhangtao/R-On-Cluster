library(rnn)

inputPath <-"d:/20180111/Scenario1/DS+ProdClass_FOL+EOL20Tage_WIPA.txt"
predVsRealPath <-"d:/20180111/Scenario1/real_vs_predict.jpg"
kpiRnnPath<-"d:/20180111/Scenario1/KPI_rnn_0.02_15.csv"
workspacePath <-"d:/20180111/Scenario1/rnn1.RData"

Data <- read.table(inputPath, header = TRUE, sep = "\t", comment.char = "")
DS <- data.frame(Data$DS)
ProdClass <- data.frame(Data$ProdClass)

Ds_unique <- data.frame(unique(DS))



#Loop for Data
timeHorizon_Input <- 12
timeHorizon_Output <- 12
WIP_Input <- matrix(0,((ncol(Data)-(timeHorizon_Output+2)-1) -(timeHorizon_Input-1))*nrow(Data),timeHorizon_Input)
WIP_Output <- matrix(0,((ncol(Data)-(timeHorizon_Output+2)-1) -(timeHorizon_Input-1))*nrow(Data),timeHorizon_Output)
WIP_In_Time <- matrix(0,((ncol(Data)-(timeHorizon_Output+2)-1) -(timeHorizon_Input-1))*nrow(Data),timeHorizon_Input)
WIP_Out_Time <- matrix(0,((ncol(Data)-(timeHorizon_Output+2)-1) -(timeHorizon_Input-1))*nrow(Data),timeHorizon_Output)
for (j in 1:(nrow(Data))){
  l=1
  
  iteration = 0
  for (i in 1:(timeHorizon_Input*((ncol(Data)-(timeHorizon_Output+2)-1)-(timeHorizon_Input-1))))
  {
    
    
    if ((i-1)%%(timeHorizon_Input)==0 ){
      iteration = iteration + 1;
      l =1
    }
    
    
    WIP_Input[j*(timeHorizon_Input*((ncol(Data)-(timeHorizon_Output+2)-1)-(timeHorizon_Input-1)))/timeHorizon_Input -(timeHorizon_Input*((ncol(Data)-(timeHorizon_Output+2)-1)-(timeHorizon_Input-1)))/timeHorizon_Input + iteration, l] <- Data[j,i-timeHorizon_Input*(iteration-1)+(iteration-1)+2]
    WIP_In_Time[j*(timeHorizon_Input*((ncol(Data)-(timeHorizon_Output+2)-1)-(timeHorizon_Input-1)))/timeHorizon_Input-(timeHorizon_Input*((ncol(Data)-(timeHorizon_Output+2)-1)-(timeHorizon_Input-1)))/timeHorizon_Input + iteration,l] <- colnames(Data[i-timeHorizon_Input*(iteration-1)+(iteration-1)+2])
    for ( out in 1:timeHorizon_Output){
      WIP_Output[j*(timeHorizon_Input*((ncol(Data)-(timeHorizon_Output+2)-1)-(timeHorizon_Input-1)))/timeHorizon_Input -(timeHorizon_Input*((ncol(Data)-(timeHorizon_Output+2)-1)-(timeHorizon_Input-1)))/timeHorizon_Input + iteration, out]  <- Data[j,i-timeHorizon_Input*(iteration-1)+(iteration-1)+2+out]
      WIP_Out_Time[j*(timeHorizon_Input*((ncol(Data)-(timeHorizon_Output+2)-1)-(timeHorizon_Input-1)))/timeHorizon_Input -(timeHorizon_Input*((ncol(Data)-(timeHorizon_Output+2)-1)-(timeHorizon_Input-1)))/timeHorizon_Input + iteration, out] <- colnames(Data[i-timeHorizon_Input*(iteration-1)+(iteration-1)+2+out])
    }
    
    l = l+1
  }
  
}
#Standardize in the Intervall [0,1]
maxIn <- max(WIP_Input)
minIn <- min(WIP_Input)
maxOut <- max(WIP_Output)
minOut <- min(WIP_Output)
WIP_Input <- (WIP_Input - minIn)/(maxIn-minIn)
WIP_Output <- (WIP_Output  - minOut)/(maxOut-minOut)

#Index for Train and Test per zufall
index <- sample(1:nrow(WIP_Input),round(0.80*nrow(WIP_Input)))
train <- index
test <- -index

#Train and Test zusammenhängender Zeitraum
#row80 <- nrow(WIP_Input)*0.8
#train <- 1:row80
#test <- (row80+1):nrow(WIP_Input)

#RNN Model
model <- trainr(Y = WIP_Output[train,], X= WIP_Input[train,], learningrate = 0.02, hidden_dim = c(8),numepochs =50, network_type = 'rnn')

#Predicted values
predictions <- predictr(model, WIP_Input[test,])

#return standardize
WIP_Input <- WIP_Input*(maxIn-minIn) + minIn
WIP_Output <- WIP_Output*(maxOut - minOut) + minOut
predictions <- predictions*(maxOut - minOut) +minOut

#Plot predictet vs. actual
plot((as.vector(WIP_Output[test,])),col='red',type='l',main = "Actual vs predicted", ylab="Actual,Predicted")
lines(as.vector(predictions),type='l', col='blue')
#legend("topright", c("Predicted","Real"),col=c('blue','red'),lty=c(1,1),lwd=c(1,1))
plot(WIP_Output[test,],predictions)
savePlot(filename=predVsRealPath, type="jpeg")
#points(WIP_Output[test,][Error>300], predictions[Error>300],pch=10,col='blue')

#DS und ProdClass Vektoren passend zu WIP_Input und Output zum besseren Zugriff auf lösung
DS_out <- data.frame(matrix(0,nrow(WIP_Input),1))
names(DS_out) <- c("DS")
for (i in 1:nrow(DS)){
  for(k in 1:((ncol(Data)-(timeHorizon_Output+2)-1) -(timeHorizon_Input-1))){
    DS_out[(i*((ncol(Data)-(timeHorizon_Output+2)-1) -(timeHorizon_Input-1)))-((ncol(Data)-(timeHorizon_Output+2)-1) -(timeHorizon_Input-1))+k,1] <- as.character(DS[i,1])
  }
}
DS_test <- DS_out[test,]

ProdClass_out <- data.frame(matrix(0,nrow(WIP_Input),1))
names(ProdClass_out) <- c("ProdClass")
for(i in 1:nrow(ProdClass)){
  for(k in 1:((ncol(Data)-(timeHorizon_Output+2)-1) -(timeHorizon_Input-1))){
    ProdClass_out[(i*((ncol(Data)-(timeHorizon_Output+2)-1) -(timeHorizon_Input-1)))-((ncol(Data)-(timeHorizon_Output+2)-1) -(timeHorizon_Input-1))+k,1] <- as.character(ProdClass[i,1])
  }
}
ProdClass_test <- ProdClass_out[test,]

#MSE pro DS über alle Stunden
quad.fehler <- (WIP_Output[test,]-predictions)^2
Dispatchstation <- data.frame(unique(DS_test))
sum.quad.fehler <- as.numeric(rowSums(quad.fehler))
sum.quad.fehler <- cbind(DS_test,sum.quad.fehler)

MSE <- matrix(0,nrow(Dispatchstation),1)
count <- matrix(0,nrow(Dispatchstation),1)
for (i in 1:nrow(Dispatchstation)){
  for (j in 1: nrow(sum.quad.fehler)){
    if (sum.quad.fehler[j,1] == Dispatchstation[i,1]){
      MSE[i,1] <- MSE[i,1] + as.numeric(sum.quad.fehler[j,2])
      count[i,1] <- count[i,1] +1
    }
  }
}
MSE.horizon <- MSE / count  # Achtung!! MSE für 5 Stunden bei dieser DS, über 5 Stunden diesen Gesamtfehler -> 1h noch durch 5 teilen!!
Wafer.Error.horizon <- sqrt(MSE.horizon)
MSE.hour <- MSE.horizon/timeHorizon_Output
Wafer.Error.hour <- sqrt(MSE.hour)

forecast_accuracy <- 1-abs(Wafer.Error.hour)/100

#Forecast Accuracy, 1 <- forecast = test, 0<- error >= 100 and 0.5 <- 2 Lose Error 
#forecast_accuracy <- 1-abs(WIP_Output[,test]-predictions)/100
for (a in 1:nrow(forecast_accuracy)){
  for (b in 1:ncol(forecast_accuracy)){
    if (forecast_accuracy[a,b] < 0){
      forecast_accuracy[a,b] = 0
    }
  }
}
#mean.forecast <- as.numeric(rowMeans(forecast_accuracy))
#mean.forecast <- cbind(DS_test,mean.forecast)
#accuracy <- matrix(0,nrow(Dispatchstation),1)
#for(a in 1:nrow(Dispatchstation)){
#  for(b in 1:nrow(mean.forecast)){
#    if (mean.forecast[b,1] == Dispatchstation[a,1]){
#      accuracy[a,1] <- accuracy[a,1] + as.numeric(mean.forecast[b,2])
#      count[a,1] <- count[a,1]+1
#    }
#  }
#}
#forecast_accuracy_mean_hour <- accuracy/count

KPI <- cbind(Dispatchstation,MSE.horizon,Wafer.Error.horizon,MSE.hour,Wafer.Error.hour,forecast_accuracy)
KPI[,2] <- gsub("\\.", ",", KPI[,2])
KPI[,3] <- gsub("\\.",",", KPI[,3])
KPI[,4] <- gsub("\\.",",", KPI[,4])
KPI[,5] <- gsub("\\.",",", KPI[,5])
KPI[,6] <- gsub("\\.",",", KPI[,6])
write.csv(KPI,kpiRnnPath) #Tabelle wegspeichern, Pfad anpassen!!
save.image(file=workspacePath) #Workspace speichern, Name muss Name von R Skript sein

#Heatmap
#Error <- WIP_Output[test,]-predictions
#Error <- cbind(DS_out[test,], Error)

#Time <- data.frame(WIP_In_Time[1:476,1])
#Time_test <- WIP_Out_Time[test,]

#sum.Error <- data.frame(matrix(0,nrow(Time),nrow(DS_test_unique)))
#for(i in 1:nrow(DS_test_unique)){
#for(j in 1:nrow(Error)){
#if(Error[j,1] == DS_test_unique[i,1]){
#for(k in 1:nrow(Time)){
# for(l in 1:ncol(Time_test)){
# if(Time[k,1]==Time_test[j,l]){
#  sum.Error[k,i] <- sum.Error[k,i] + as.numeric(Error[j,l+1])
# }
#}
#}
#}
#}
#}

#colnames(sum.Error)<- t(DS_test_unique)
#Avg <- rowMeans(abs(sum.Error))
#Error.Map <- cbind(sum.Error, Avg)
#for(z in 1:ncol(Error.Map)){
#  Error.Map[,z] <- gsub("\\.",",",Error.Map[,z])
#}
#Error.Map <- cbind(Time,Error.Map)
#write.csv(Error.Map, row.names = FALSE, "H:/Masterarbeit/neuesFormat_rnn/ErrorMap_rnn_0.5_3.csv")

